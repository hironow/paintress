# Mission — Règles d'engagement

Ce fichier définit les règles d'engagement de l'Expédition.
Tous les Expéditionnaires doivent lire ce fichier et accomplir leur mission.

---

## Acquisition de la mission

1. Utiliser Linear pour récupérer les issues non terminées (tous les statuts sauf Done — y compris les issues bloquées en Testing ou In Review des Expéditions précédentes)
2. Si un **Gradient Gauge** est fourni, l'utiliser comme indicateur du niveau de complexité à entreprendre ; sinon, choisir une issue appropriée selon votre propre jugement

## Évaluation de la mission

Analyser le contenu de l'issue et la classer dans l'un des trois types suivants :

### implement (implémentation)

Implémentation de code, ajout de fonctionnalités, refactoring, etc.

### verify (vérification)

Tests E2E, revue UI, complétion de checklist, vérification de comportement, etc.
Critères : la description contient des mots-clés comme « test », « vérifier », « contrôle », « QA », « E2E »,
ou inclut une checklist (`- [ ]`).

### fix (correction)

Transition automatique depuis les résultats de verify. Les Expéditionnaires ne sélectionnent pas ce type directement.

---

## Procédure implement

1. `git checkout <base-branch> && git pull origin <base-branch>`
2. Créer la branche : `feat/<issue-id>-<description-courte>`
3. TDD : écrire les tests -> implémenter -> faire passer les tests
4. Commits fréquents (inclure l'ID de l'issue dans les messages de commit)
5. Vérification lint / format
6. Si l'échec persiste après 3 tentatives de correction -> ignorer (consigner la leçon dans le journal)
7. Créer la PR via GitHub (corps incluant `Closes <issue-id>`)
8. Mettre à jour l'issue en « In Review » via Linear

## Procédure verify

1. Vérifier que le serveur dev est en cours d'exécution (accès à l'URL)
2. Si des outils d'automatisation de navigateur sont disponibles (Playwright, Chrome DevTools, etc.), les utiliser pour ouvrir un navigateur et naviguer vers la page cible
3. Exécuter les éléments de la checklist **un par un** :
   a. Interagir avec l'UI
   b. Comparer les résultats attendus et réels
   c. Capture d'écran si l'automatisation du navigateur est disponible
   d. Enregistrer le résultat (Pass / Fail + détails)
4. Créer un rapport QA et commenter l'issue via Linear
5. **Aucun défaut** : mettre l'issue à « Done »
6. **Défauts trouvés** : -> transition vers fix

## Procédure fix (transition automatique depuis verify)

Pour chaque défaut :

1. Créer une issue bug via Linear
2. `git checkout <base-branch> && git pull origin <base-branch>`
3. Branche : `fix/<bug-issue-id>-<description-courte>`
4. Implémenter la correction et écrire les tests
5. Si l'échec persiste après 3 tentatives de correction -> ignorer (consigner la leçon dans le journal)
6. Créer la PR via GitHub (corps incluant `Closes <bug-issue-id>`)

---

## Interdictions

- Ne pas faire de force push
- Ne pas commiter directement sur la branche de base
- Ne pas créer de PR avec des tests en échec
- Ne pas arrêter le serveur dev (géré par un processus externe)
- Ne pas re-vérifier les corrections au sein de la même Expédition — laisser la vérification à la prochaine Expédition
- Ne pas modifier `.expedition/mission.md`

## Gestion de l'ambiguïté

- Exécuter les éléments ambigus selon le meilleur jugement et consigner le raisonnement dans le journal
- Ignorer les issues aux spécifications floues et les consigner dans le journal
- En cas de doute, ignorer et laisser à la prochaine Expédition
