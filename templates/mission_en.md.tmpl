# Mission — Rules of Engagement

This file defines the rules of engagement for the Expedition.
All Expeditioners must read this file and carry out their mission.

---

## Obtaining the Mission

1. Use Linear to retrieve unfinished issues (all statuses except Done — including issues stalled in Testing or In Review from previous Expeditions)
2. If a **Gradient Gauge** is provided, use it as a hint for how much complexity to take on; otherwise, pick an appropriate issue based on your own judgment

## Mission Assessment

Analyze the issue content and classify it into one of three types:

### implement

Code implementation, feature additions, refactoring, etc.

### verify

E2E testing, UI review, checklist completion, behavior verification, etc.
Criteria: description contains keywords like "test", "check", "verify", "QA", "E2E",
or includes a checklist (`- [ ]`).

### fix

When defects are found during verify, you transition to fix within the same Expedition. This is not a separate selection — it follows naturally from verify results.

---

## implement Procedure

1. `git checkout <base-branch> && git pull origin <base-branch>`
2. Update the issue to a started/in-progress status in Linear (e.g. "In Progress")
3. Create branch: `feat/<issue-id>-<short-description>`
4. TDD: write tests -> implement -> make tests pass
5. Commit frequently (include issue ID in commit messages)
6. Run lint / format checks
7. If it still fails after 3 fix attempts -> skip (record lesson in journal)
8. Create PR via GitHub (body includes `Closes <issue-id>`)
9. Update the issue to a review status in Linear (e.g. "In Review")
10. Code review is handled by the orchestrator (Paintress) after PR creation — do not run review commands yourself

## verify Procedure

1. Update the issue to a testing/QA status in Linear (e.g. "Testing") if not already in one
2. Confirm dev server is running (check URL accessibility)
3. If browser automation tools are available (Playwright, Chrome DevTools, etc.), use them to open a browser and navigate to the target page
4. Execute checklist items **one by one**:
   a. Interact with UI
   b. Compare expected vs actual results
   c. Take screenshot if browser automation is available
   d. Record result (Pass / Fail + details)
5. Create QA report and comment on issue via Linear
6. **If no defects**: update the issue to a completed status in Linear (e.g. "Done")
7. **If defects found**: -> transition to fix

## fix Procedure (auto-transition from verify)

For each defect:

1. File a bug issue via Linear
2. `git checkout <base-branch> && git pull origin <base-branch>`
3. Update the bug issue to a started/in-progress status in Linear (e.g. "In Progress")
4. Branch: `fix/<bug-issue-id>-<short-description>`
5. Implement fix and write tests
6. If it still fails after 3 fix attempts -> skip (record lesson in journal)
7. Create PR via GitHub (body includes `Closes <bug-issue-id>`)
8. Update the bug issue to a review status in Linear (e.g. "In Review")
9. Code review is handled by the orchestrator (Paintress) after PR creation — do not run review commands yourself

---

## Prohibitions

- Do not force push
- Do not commit directly to the base branch
- Do not create a PR with failing tests
- Do not stop the dev server (managed by external process)
- Do not re-verify fixes within the same Expedition — leave verification to the next Expedition

## Handling Ambiguity

- Execute ambiguous items using best judgment and record reasoning in journal
- Skip issues with unclear specs and record in journal
- If unsure, skip and leave it to the next Expedition
